{"reviews":[{"author":{"login":"coderabbitai"},"authorAssociation":"NONE","body":"**Actionable comments posted: 16**\n\n<details>\n<summary>üßπ Nitpick comments (7)</summary><blockquote>\n\n<details>\n<summary>frontend/scripts/test-auth-flow.ts (1)</summary><blockquote>\n\n`5-6`: **Hardcoded `BASE_URL` ‚Äî consider making it configurable.**\n\nThe test script hardcodes `http://localhost:3000`. An environment variable would make it reusable across environments.\n\n\n<details>\n<summary>‚ôªÔ∏è Use environment variable</summary>\n\n```diff\n-    const BASE_URL = 'http://localhost:3000';\n+    const BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:3000';\n```\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nVerify each finding against the current code and only fix it if needed.\n\nIn `@frontend/scripts/test-auth-flow.ts` around lines 5 - 6, The BASE_URL constant\nin testAuthFlow is hardcoded; change it to read from an environment variable\n(e.g., process.env.TEST_BASE_URL or process.env.BASE_URL) with a sensible\nfallback like 'http://localhost:3000' so the script can run against different\nenvironments; update the declaration of BASE_URL inside async function\ntestAuthFlow to use that env lookup and ensure any CI/dev docs or .env.example\nmention the new TEST_BASE_URL variable.\n```\n\n</details>\n\n</blockquote></details>\n<details>\n<summary>frontend/src/middleware.ts (1)</summary><blockquote>\n\n`9-9`: **`isPublicPath` check for `/api/` is unreachable ‚Äî matcher only routes `/dashboard/*` and `/login` to this middleware.**\n\nThe `pathname.startsWith('/api/')` condition will never be true because the `config.matcher` (Lines 35-39) doesn't include API paths. This variable is also only implicitly used (the logic falls through to `NextResponse.next()` on Line 32 for unmatched patterns). Consider simplifying.\n\n\n<details>\n<summary>‚ôªÔ∏è Remove dead path check</summary>\n\n```diff\n-    const isPublicPath = pathname === '/login' || pathname === '/' || pathname.startsWith('/api/');\n+    // Matcher already limits this middleware to /dashboard/* and /login\n```\n\nThe existing conditional checks on Lines 23 and 28 already handle both matched paths correctly.\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nVerify each finding against the current code and only fix it if needed.\n\nIn `@frontend/src/middleware.ts` at line 9, The isPublicPath check includes\npathname.startsWith('/api/') which is dead because config.matcher doesn't route\nAPI paths to this middleware; remove the '/api/' condition and simplify the\nlogic by redefining isPublicPath to only check pathname === '/login' || pathname\n=== '/' (or eliminate the isPublicPath variable and use those two checks\ninline), ensuring the existing fall-through to NextResponse.next() and the other\npathname checks remain unchanged; update references to the isPublicPath variable\nand keep middleware behavior intact (see isPublicPath, pathname, config.matcher,\nand NextResponse.next).\n```\n\n</details>\n\n</blockquote></details>\n<details>\n<summary>frontend/src/utils/stellar.ts (1)</summary><blockquote>\n\n`68-71`: **Unused `serverUrl` variable in `createContractInstance`.**\n\n`serverUrl` is assigned on Line 69 but never used. The function returns `new Contract(contractId)` without it. This is pre-existing, but since the file is being touched, consider cleaning it up or adding a TODO.\n\n\n<details>\n<summary>‚ôªÔ∏è Suggested cleanup</summary>\n\n```diff\n-export const createContractInstance = (contractId: string, network: 'testnet' | 'mainnet' = 'testnet') => {\n-  const serverUrl = NETWORKS[network].soroban;\n-  return new Contract(contractId);\n-};\n+export const createContractInstance = (contractId: string, _network: 'testnet' | 'mainnet' = 'testnet') => {\n+  // TODO: Initialize SorobanRpc.Server with NETWORKS[network].soroban when needed\n+  return new Contract(contractId);\n+};\n```\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nVerify each finding against the current code and only fix it if needed.\n\nIn `@frontend/src/utils/stellar.ts` around lines 68 - 71, The function\ncreateContractInstance defines serverUrl from NETWORKS[network].soroban but\nnever uses it; either remove the unused serverUrl assignment or wire it into the\nContract creation so the network endpoint is actually used (e.g., pass serverUrl\ninto the Contract constructor or its init/config), updating the return from new\nContract(contractId) accordingly and keeping the function name\ncreateContractInstance and references to NETWORKS and Contract consistent.\n```\n\n</details>\n\n</blockquote></details>\n<details>\n<summary>frontend/src/app/api/v1/auth/verify/route.ts (1)</summary><blockquote>\n\n`6-50`: **Nonce is not bound to the requesting `publicKey` ‚Äî consider defense-in-depth.**\n\nThe challenge endpoint stores the nonce in a cookie without associating it with a specific `publicKey`. While signature verification prevents impersonation (an attacker can't forge a signature for someone else's key), binding the nonce to the `publicKey` at challenge time and verifying that binding at verify time would add a layer of protection against potential cookie-replay or session-confusion scenarios.\n\n\n<details>\n<summary>üõ°Ô∏è Bind nonce to publicKey</summary>\n\nIn the **challenge** endpoint, store the publicKey alongside the nonce:\n```diff\n- cookieStore.set('auth-nonce', nonce, { ... });\n+ cookieStore.set('auth-nonce', JSON.stringify({ nonce, publicKey }), { ... });\n```\n\nIn the **verify** endpoint, validate the binding:\n```diff\n- const nonce = cookieStore.get('auth-nonce')?.value;\n+ const nonceData = cookieStore.get('auth-nonce')?.value;\n+ const { nonce, publicKey: boundKey } = JSON.parse(nonceData || '{}');\n+ if (boundKey !== publicKey) {\n+   return NextResponse.json({ error: 'Challenge mismatch' }, { status: 400 });\n+ }\n```\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nVerify each finding against the current code and only fix it if needed.\n\nIn `@frontend/src/app/api/v1/auth/verify/route.ts` around lines 6 - 50, The nonce\nstored in the 'auth-nonce' cookie is not bound to the requesting publicKey (in\nthe challenge/POST flow), so bind them: when creating the nonce in the challenge\nendpoint, store an object { nonce, publicKey, expiresAt } (or include publicKey\nin the cookie value) instead of just the raw nonce; then in the verify POST\nhandler (function POST, using cookies(), Keypair.fromPublicKey(...), and the\n'auth-nonce' cookie) parse and validate that the publicKey from the request\nmatches the publicKey bound to the stored nonce (and check expiry) before\nrunning keypair.verify, then proceed to signToken and setAuthCookies only if the\nbinding matches.\n```\n\n</details>\n\n</blockquote></details>\n<details>\n<summary>frontend/src/components/auth/ConnectButton.tsx (1)</summary><blockquote>\n\n`12-31`: **Verbose development notes left in production code.**\n\nLines 12-18 and 26-31 contain extensive reasoning comments that read more like development notes than code documentation. Consider replacing with concise comments or removing them entirely ‚Äî the code is self-explanatory.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nVerify each finding against the current code and only fix it if needed.\n\nIn `@frontend/src/components/auth/ConnectButton.tsx` around lines 12 - 31, Remove\nthe verbose development notes around the connection/login flow and replace them\nwith a concise comment (or remove entirely) that states the intent: e.g., \"Chain\nconnect() to obtain public key then call login(key) to perform challenge/verify\nvia useWalletAuth; if publicKey exists but no JWT, consider auto-login on 401.\"\nUpdate or remove the multi-line explanations in the block referencing connect,\nlogin, useWalletAuth, publicKey, and isConnected so only a short, descriptive\ncomment remains and the implementation (calling connect() then await login(key))\nstays unchanged.\n```\n\n</details>\n\n</blockquote></details>\n<details>\n<summary>frontend/src/app/api/v1/auth/challenge/route.ts (1)</summary><blockquote>\n\n`5-30`: **Consider validating `publicKey` format and adding rate limiting.**\n\nThe endpoint accepts any truthy string as `publicKey` without validating it's a legitimate Stellar public key. While the verify endpoint will fail on invalid keys, rejecting them early provides better error messages and reduces unnecessary nonce generation. Additionally, this endpoint has no rate limiting, which could allow nonce-generation spam.\n\n\n<details>\n<summary>üõ°Ô∏è Add publicKey format validation</summary>\n\n```diff\n import { NextResponse } from 'next/server';\n import { cookies } from 'next/headers';\n import crypto from 'crypto';\n+import { isValidAddress } from '@/utils/stellar';\n \n export async function POST(request: Request) {\n     try {\n         const { publicKey } = await request.json();\n \n-        if (!publicKey) {\n+        if (!publicKey || !isValidAddress(publicKey)) {\n-            return NextResponse.json({ error: 'Public key required' }, { status: 400 });\n+            return NextResponse.json({ error: 'Valid Stellar public key required' }, { status: 400 });\n         }\n```\n</details>\n\n\nConsider adding rate limiting (e.g., per-IP or per-publicKey) to prevent nonce-generation abuse. This could be done at the middleware or infrastructure level.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nVerify each finding against the current code and only fix it if needed.\n\nIn `@frontend/src/app/api/v1/auth/challenge/route.ts` around lines 5 - 30, The\nPOST handler accepts any truthy publicKey and generates a nonce; add early\nvalidation and rate-limiting before nonce generation: in the POST function\nvalidate the incoming publicKey format (e.g., use Stellar\nStrKey.isValidEd25519PublicKey or a strict regex) and return a 400 with a clear\nmessage if invalid, then enforce rate limits (per-IP or per-publicKey) either\nvia middleware or a quick check inside POST using a store (in-memory/Redis) to\nthrottle nonce creation; keep the cookie storage logic\n(cookieStore.set('auth-nonce', ...)) and error handling unchanged but only run\nthem after validation and rate-limit checks pass.\n```\n\n</details>\n\n</blockquote></details>\n<details>\n<summary>frontend/src/lib/auth.ts (1)</summary><blockquote>\n\n`7-7`: **Replace `payload: any` with a typed interface.**\n\nUsing `any` opts out of type-checking for the JWT payload, making it easy to accidentally include sensitive fields or misread the payload shape downstream.\n\n<details>\n<summary>‚ôªÔ∏è Proposed fix</summary>\n\n```diff\n+interface TokenPayload {\n+  publicKey: string;\n+  [key: string]: unknown;\n+}\n+\n-export async function signToken(payload: any, expiresIn: string = '1h') {\n+export async function signToken(payload: TokenPayload, expiresIn: string = '1h') {\n```\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nVerify each finding against the current code and only fix it if needed.\n\nIn `@frontend/src/lib/auth.ts` at line 7, Replace the untyped payload in signToken\nwith a proper interface: declare an exported interface (e.g., TokenPayload or\nJwtPayload) that lists expected fields (for example sub: string, email?: string,\nroles?: string[], plus an index signature for extra safe fields) and change the\nsignature to signToken(payload: TokenPayload, expiresIn: string = '1h'); update\nany related functions that construct or read the token to use this new interface\nso callers get compile-time checks and you avoid using `any` in signToken.\n```\n\n</details>\n\n</blockquote></details>\n\n</blockquote></details>\n\n<details>\n<summary>ü§ñ Prompt for all review comments with AI agents</summary>\n\n```\nVerify each finding against the current code and only fix it if needed.\n\nInline comments:\nIn `@frontend/scripts/test-auth-flow.ts`:\n- Around line 33-39: This test uses keypair.sign(Buffer.from(nonce)) to build\nsignedMessage but that does not mimic Freighter's signMessage() response\nstructure; update the test around keypair.sign, signedMessage and nonce to\neither simulate Freighter's actual returned shape/encoding or at minimum add a\nclear comment above the signing block noting \"This only tests server-side\ned25519 signature format and does not emulate Freighter.signMessage()\nresponse/encoding\" so reviewers/maintainers know this isn't exercising the real\nFreighter path.\n\nIn `@frontend/src/app/api/v1/auth/verify/route.ts`:\n- Line 29: The verify call uses Buffer.from (Buffer) which may fail in Edge\nruntime; either add export const runtime = 'nodejs' at the top of this file to\nforce Node.js runtime, or make the code runtime-agnostic by replacing Buffer\nusage around keypair.verify (the call using keypair.verify, nonce and\nsignedMessage) with a TextEncoder for nonce and a base64-to-Uint8Array decode\nfor signedMessage so keypair.verify receives Uint8Array inputs instead of\nBuffer.\n- Around line 28-29: The frontend is sending the entire signMessage() response\nobject to the verify endpoint and also omits the required address parameter,\ncausing backend Buffer.from(signedMessage, 'base64') to fail; update the sign\nflow in useWalletAuth.ts to call signMessage(nonce, { address: pk }), then\ndestructure and validate the response (check response.error and\nresponse.signedMessage) and send only response.signedMessage along with\npublicKey in the POST body to the verify endpoint; keep references to\nsignMessage, signedMessage, signerAddress and the verify endpoint to locate and\nfix the code paths.\n\nIn `@frontend/src/app/login/page.tsx`:\n- Around line 8-18: LoginPage currently calls useWalletAuth() and sets up an\nempty useEffect that never observes the ConnectButton's state because\nConnectButton also instantiates its own useWalletAuth; remove the unused hook\nand effect to avoid dual instances and delete the unused useRouter import,\nkeeping LoginPage as a simple component that renders ConnectButton (leave\nConnectButton's internal login/redirect flow intact); specifically remove the\nconst { isConnected, publicKey } = useWalletAuth() line, the useEffect block\nreferencing isConnected/publicKey/router, and any unused useRouter\nimport/variable.\n\nIn `@frontend/src/components/auth/ConnectButton.tsx`:\n- Around line 7-9: The component destructures error from useWalletAuth but never\nrenders it; update ConnectButton to display the error state (from error) in the\nUI so users see failures from connect() or login(); add a conditional render of\nthe error string (e.g., show a small red text paragraph) just below the button\nand before the modal, ensuring it updates when error changes and does not\ninterfere with isModalOpen/setIsModalOpen logic.\n- Around line 11-24: Update the frontend logout call to use the correct endpoint\n'/api/auth/logout' (replace any '/api/v1/auth/logout' usages, e.g., in your\nlogout handler function). In the backend logout controller, restore and call\nauthService.revokeSession(req.user!.jti) (uncomment and ensure\nauthService.revokeSession is implemented) and then clear the httpOnly\ncookie/response cookie so the session cookie is removed; keep the existing\nresponse shape after successful revocation. Ensure error handling around\nrevokeSession remains consistent with other auth flows.\n\nIn `@frontend/src/components/auth/WalletPickerModal.tsx`:\n- Around line 1-5: Remove the unused imports in WalletPickerModal.tsx: delete\nthe named import isAllowed from '@stellar/freighter-api' and the clsx import\nfrom 'clsx' since the code uses window.freighter directly and only twMerge is\nused; keep the other imports (useEffect, useState, X, twMerge) intact and run a\nquick lint to ensure no other unused symbols remain.\n- Around line 34-95: WalletPickerModal is missing dialog accessibility and\nkeyboard interactions: add role=\"dialog\" and aria-modal=\"true\" to the modal\ncontainer, give the <h2> a stable id (e.g., labelId) and set aria-labelledby on\nthe dialog, wire the existing onClose prop to an Escape-key handler (listen for\nkeydown Escape when the modal mounts and remove on unmount), and implement focus\nmanagement by focusing the first focusable element on mount and trapping\nTab/Shift+Tab inside the modal until it closes (release focus and restore\npreviously focused element on unmount). Ensure handlers reference\nWalletPickerModal, onClose, and the heading id so reviewers can find the\nchanges.\n- Around line 16-29: Replace the fragile window.freighter check in the\nuseEffect/checkFreighter logic with the official isConnected() API from\n`@stellar/freighter-api`: import and call isConnected() inside the async\ncheckFreighter function, await its result, then call\nsetHasFreighter(result.isConnected) (and optionally handle/log result.error);\nremove the `@ts-ignore` and the direct window.freighter probe so detection uses\nthe documented isConnected() contract.\n\nIn `@frontend/src/hooks/useWalletAuth.ts`:\n- Line 92: Replace hard navigations and ensure server-side logout is invoked:\nimport and use Next.js useRouter from next/navigation inside useWalletAuth and\nreplace window.location.href = '/dashboard' and '/login' with\nrouter.push('/dashboard') and router.push('/login'); update the logout()\nfunction to call await fetch('/api/v1/auth/logout', { method: 'POST',\ncredentials: 'include' }) before clearing client state, check response.ok and\nhandle non-2xx (log error and avoid clearing auth state or surface an error to\nthe caller) so httpOnly cookies are cleared server-side; reference the\nuseWalletAuth hook and its logout() flow and replace window.location.href usages\naccordingly.\n- Around line 79-87: The code is sending the whole object returned by\nsignMessage() to /api/v1/auth/verify instead of the signature bytes; call\nsignMessage(nonce) and destructure its result to read the signedMessage property\n(e.g. const { signedMessage: signedMessageBase64, signerPublicKey } = await\nsignMessage(nonce)), decode the base64 string into raw bytes\n(Buffer.from(signedMessageBase64, \"base64\")) and pass that decoded signature\n(not the full object) as the signedMessage field in the POST body to\nfetch('/api/v1/auth/verify') along with the public key (pk).\n- Around line 39-49: The check on the result of setAllowed() is using object\ntruthiness and thus always passes; update the conditional in useWalletAuth\n(where setAllowed() is called) to read the actual boolean field returned by\nsetAllowed() (the same shape as isAllowed()) instead of testing the whole object\n‚Äî e.g., extract the boolean property from the setAllowed() response and use that\nin the if/else before calling getAddress(), and keep the existing error branch\nthat calls setError('User refused connection') when that boolean is false;\nensure you update any related variable usage (key, setIsConnected, setPublicKey)\nto only run when the boolean indicates permission granted.\n- Around line 20-32: The checkConnection() effect currently treats isAllowed()\nas a boolean and swallows errors; modify checkConnection() to await isAllowed(),\ninspect its returned .isAllowed property before calling getAddress(), and wrap\nthe body in a try/catch so API/extension errors are caught and surfaced (e.g.,\ncall console.error or update an error state). Specifically, change the condition\nfrom if (await isAllowed()) to const allowed = await isAllowed(); if\n(allowed?.isAllowed) and add error handling around getAddress() and set state\n(setIsConnected/setPublicKey) inside the try block, handling failures in the\ncatch.\n\nIn `@frontend/src/lib/auth.ts`:\n- Around line 4-5: Replace the insecure fallback by failing startup when\nJWT_SECRET_KEY is missing: remove the hardcoded default assigned to SECRET_KEY\nand instead read process.env.JWT_SECRET_KEY and throw a clear error (or exit) if\nit's undefined/empty, then keep creating the key with new\nTextEncoder().encode(SECRET_KEY); ensure you update the symbols SECRET_KEY and\nkey in frontend/src/lib/auth.ts so the app never continues with a public default\nsecret.\n- Around line 1-57: The project is using the deprecated Next.js middleware\nconvention; rename the file frontend/src/middleware.ts to frontend/src/proxy.ts\nand update the exported function name from middleware to proxy (i.e., change\nexport async function middleware(...) ‚Üí export async function proxy(...)); also\nupdate any related Next.js config flags (for example, rename\nskipMiddlewareUrlNormalize ‚Üí skipProxyUrlNormalize) and verify runtime\ncompatibility (proxy is Node.js-only); you can alternatively run the codemod npx\n`@next/codemod`@canary middleware-to-proxy . to automate this.\n\nIn `@frontend/src/middleware.ts`:\n- Around line 5-32: The middleware currently only checks accessToken in\nmiddleware(request) and must be extended to silently refresh expired access\ntokens: if verifyToken(accessToken) fails but\nrequest.cookies.get('refreshToken') exists, call a refresh routine (e.g.,\nrefreshAccessToken or verifyRefreshToken) to validate the refresh token and\nobtain a new access token (and updated refresh token if returned), set the new\naccessToken cookie on the response, and then allow the request to proceed\n(return NextResponse.next() with the updated Set-Cookie headers). If the refresh\nattempt fails or no refreshToken is present, keep the existing behavior of\nredirecting to '/login' for protected routes; also ensure the login route still\nredirects to '/dashboard' when a valid accessToken (or successful refresh) is\npresent. Include references to middleware, verifyToken, and the new\nrefreshAccessToken/verifyRefreshToken flow to locate where to add this logic.\n\n---\n\nNitpick comments:\nIn `@frontend/scripts/test-auth-flow.ts`:\n- Around line 5-6: The BASE_URL constant in testAuthFlow is hardcoded; change it\nto read from an environment variable (e.g., process.env.TEST_BASE_URL or\nprocess.env.BASE_URL) with a sensible fallback like 'http://localhost:3000' so\nthe script can run against different environments; update the declaration of\nBASE_URL inside async function testAuthFlow to use that env lookup and ensure\nany CI/dev docs or .env.example mention the new TEST_BASE_URL variable.\n\nIn `@frontend/src/app/api/v1/auth/challenge/route.ts`:\n- Around line 5-30: The POST handler accepts any truthy publicKey and generates\na nonce; add early validation and rate-limiting before nonce generation: in the\nPOST function validate the incoming publicKey format (e.g., use Stellar\nStrKey.isValidEd25519PublicKey or a strict regex) and return a 400 with a clear\nmessage if invalid, then enforce rate limits (per-IP or per-publicKey) either\nvia middleware or a quick check inside POST using a store (in-memory/Redis) to\nthrottle nonce creation; keep the cookie storage logic\n(cookieStore.set('auth-nonce', ...)) and error handling unchanged but only run\nthem after validation and rate-limit checks pass.\n\nIn `@frontend/src/app/api/v1/auth/verify/route.ts`:\n- Around line 6-50: The nonce stored in the 'auth-nonce' cookie is not bound to\nthe requesting publicKey (in the challenge/POST flow), so bind them: when\ncreating the nonce in the challenge endpoint, store an object { nonce,\npublicKey, expiresAt } (or include publicKey in the cookie value) instead of\njust the raw nonce; then in the verify POST handler (function POST, using\ncookies(), Keypair.fromPublicKey(...), and the 'auth-nonce' cookie) parse and\nvalidate that the publicKey from the request matches the publicKey bound to the\nstored nonce (and check expiry) before running keypair.verify, then proceed to\nsignToken and setAuthCookies only if the binding matches.\n\nIn `@frontend/src/components/auth/ConnectButton.tsx`:\n- Around line 12-31: Remove the verbose development notes around the\nconnection/login flow and replace them with a concise comment (or remove\nentirely) that states the intent: e.g., \"Chain connect() to obtain public key\nthen call login(key) to perform challenge/verify via useWalletAuth; if publicKey\nexists but no JWT, consider auto-login on 401.\" Update or remove the multi-line\nexplanations in the block referencing connect, login, useWalletAuth, publicKey,\nand isConnected so only a short, descriptive comment remains and the\nimplementation (calling connect() then await login(key)) stays unchanged.\n\nIn `@frontend/src/lib/auth.ts`:\n- Line 7: Replace the untyped payload in signToken with a proper interface:\ndeclare an exported interface (e.g., TokenPayload or JwtPayload) that lists\nexpected fields (for example sub: string, email?: string, roles?: string[], plus\nan index signature for extra safe fields) and change the signature to\nsignToken(payload: TokenPayload, expiresIn: string = '1h'); update any related\nfunctions that construct or read the token to use this new interface so callers\nget compile-time checks and you avoid using `any` in signToken.\n\nIn `@frontend/src/middleware.ts`:\n- Line 9: The isPublicPath check includes pathname.startsWith('/api/') which is\ndead because config.matcher doesn't route API paths to this middleware; remove\nthe '/api/' condition and simplify the logic by redefining isPublicPath to only\ncheck pathname === '/login' || pathname === '/' (or eliminate the isPublicPath\nvariable and use those two checks inline), ensuring the existing fall-through to\nNextResponse.next() and the other pathname checks remain unchanged; update\nreferences to the isPublicPath variable and keep middleware behavior intact (see\nisPublicPath, pathname, config.matcher, and NextResponse.next).\n\nIn `@frontend/src/utils/stellar.ts`:\n- Around line 68-71: The function createContractInstance defines serverUrl from\nNETWORKS[network].soroban but never uses it; either remove the unused serverUrl\nassignment or wire it into the Contract creation so the network endpoint is\nactually used (e.g., pass serverUrl into the Contract constructor or its\ninit/config), updating the return from new Contract(contractId) accordingly and\nkeeping the function name createContractInstance and references to NETWORKS and\nContract consistent.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit for review status -->","submittedAt":"2026-02-19T19:06:26Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED"}]}
